This is an adaptation of Pavel Machek's nbd-swap patch for 2.1.123
from http://atrey.karlin.mff.cuni.cz/~pavel/nbd/nbd.swap-patch.123

I put a lot of GFP_NUCLEONIC's in the net drivers.  He only had
them in the 3c59x driver, so I put them in all of them.  May be
wrong, but normally a diskless machine doesn't have so many net
devices, so I figure it won't hurt.

A few fixes failed and could not be fixed in a simple way,
and I am not sure whether they were important.  They are appended.

It goes in cleanly against 2.2.13pre17.  On 2.2.14pre3 there is
a failure in the tulip driver.  I think it is safe to ignore
this failure.

Only in linux/drivers/net: 3c59x.c.orig
Only in linux/drivers/net: 3c59x.c.rej
diff -ru linux-2.2.13pre17/drivers/net/82596.c linux/drivers/net/82596.c
--- linux-2.2.13pre17/drivers/net/82596.c	Thu Jan  7 16:46:59 1999
+++ linux/drivers/net/82596.c	Sun Oct 31 19:20:50 1999
@@ -825,7 +825,7 @@
 		short length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;
 		dev->trans_start = jiffies;
 
-		tx_cmd = (struct tx_cmd *) kmalloc((sizeof(struct tx_cmd) + sizeof(struct i596_tbd)), GFP_ATOMIC);
+		tx_cmd = (struct tx_cmd *) kmalloc((sizeof(struct tx_cmd) + sizeof(struct i596_tbd)), GFP_NUCLEONIC);
 		if (tx_cmd == NULL) {
 			printk("%s: i596_xmit Memory squeeze, dropping packet.\n", dev->name);
 			lp->stats.tx_dropped++;
@@ -1287,7 +1287,7 @@
 	if (dev->mc_count > 0) {
 		struct dev_mc_list *dmi;
 		unsigned char *cp;
-		cmd = (struct i596_cmd *) kmalloc(sizeof(struct i596_cmd) + 2 + dev->mc_count * 6, GFP_ATOMIC);
+		cmd = (struct i596_cmd *) kmalloc(sizeof(struct i596_cmd) + 2 + dev->mc_count * 6, GFP_NUCLEONIC);
 		if (cmd == NULL) {
 			printk("%s: set_multicast Memory squeeze.\n", dev->name);
 			return;
Only in linux/drivers/net: 82596.c~
diff -ru linux-2.2.13pre17/drivers/net/acenic.c linux/drivers/net/acenic.c
--- linux-2.2.13pre17/drivers/net/acenic.c	Wed Oct 13 20:36:43 1999
+++ linux/drivers/net/acenic.c	Sun Oct 31 19:21:00 1999
@@ -897,7 +897,7 @@
 		struct sk_buff *skb;
 
 		ap->rx_std_ring[i].flags = 0;
-		skb = alloc_skb(ACE_STD_MTU + ETH_HLEN + 6, GFP_ATOMIC);
+		skb = alloc_skb(ACE_STD_MTU + ETH_HLEN + 6, GFP_NUCLEONIC);
 		ap->rx_std_skbuff[i] = skb;
 
 		/*
@@ -953,7 +953,7 @@
 		struct sk_buff *skb;
 
 		ap->rx_jumbo_ring[i].flags = 0;
-		skb = alloc_skb(ACE_JUMBO_MTU + ETH_HLEN + 6, GFP_ATOMIC);
+		skb = alloc_skb(ACE_JUMBO_MTU + ETH_HLEN + 6, GFP_NUCLEONIC);
 		ap->rx_jumbo_skbuff[i] = skb;
 
 		/*
@@ -1123,7 +1123,7 @@
 		size = oldrxdesc->size;
 
 		if (size < PKT_COPY_THRESHOLD) {
-			skb = alloc_skb(size + 2, GFP_ATOMIC);
+			skb = alloc_skb(size + 2, GFP_NUCLEONIC);
 			if (skb == NULL){
 				printk(KERN_ERR "%s: Out of memory\n",
 				       dev->name);
@@ -1142,7 +1142,7 @@
 
 			skb_put(skb, size);
 
-			newskb = alloc_skb(size + 2, GFP_ATOMIC);
+			newskb = alloc_skb(size + 2, GFP_NUCLEONIC);
 			if (newskb == NULL){
 				printk(KERN_ERR "%s: Out of memory\n",
 				       dev->name);
Only in linux/drivers/net: acenic.c~
diff -ru linux-2.2.13pre17/drivers/net/arcnet.c linux/drivers/net/arcnet.c
--- linux-2.2.13pre17/drivers/net/arcnet.c	Wed Oct 13 20:51:23 1999
+++ linux/drivers/net/arcnet.c	Sun Oct 31 19:21:08 1999
@@ -1128,7 +1128,7 @@
 
       in->sequence=arcsoft->sequence;
 
-      skb = alloc_skb(length, GFP_ATOMIC);
+      skb = alloc_skb(length, GFP_NUCLEONIC);
       if (skb == NULL) {
 	BUGMSG(D_NORMAL,"Memory squeeze, dropping packet.\n");
 	lp->stats.rx_dropped++;
@@ -1253,7 +1253,7 @@
 
 	  in->skb=skb=alloc_skb(508*in->numpackets
 				+ sizeof(struct ClientData),
-				GFP_ATOMIC);
+				GFP_NUCLEONIC);
 	  if (skb == NULL) {
 	    BUGMSG(D_NORMAL,"(split) memory squeeze, dropping packet.\n");
 	    lp->stats.rx_dropped++;
@@ -1665,7 +1665,7 @@
 	BUGMSG(D_DURING,"it's an ethernet-encap packet (length=%d)\n",
 			length);
 
-       	skb = alloc_skb(length, GFP_ATOMIC);
+       	skb = alloc_skb(length, GFP_NUCLEONIC);
        	if (skb == NULL) {
        		BUGMSG(D_NORMAL,"Memory squeeze, dropping packet.\n");
        		lp->stats.rx_dropped++;
@@ -1807,7 +1807,7 @@
 
   {    /* was "if not split" in A protocol, S is never split */
 
-    skb = alloc_skb(length, GFP_ATOMIC);
+    skb = alloc_skb(length, GFP_NUCLEONIC);
     if (skb == NULL) {
       BUGMSG(D_NORMAL,"Memory squeeze, dropping packet.\n");
       lp->stats.rx_dropped++;
Only in linux/drivers/net: arcnet.c~
diff -ru linux-2.2.13pre17/drivers/net/atari_pamsnet.c linux/drivers/net/atari_pamsnet.c
--- linux-2.2.13pre17/drivers/net/atari_pamsnet.c	Wed Oct  7 22:51:45 1998
+++ linux/drivers/net/atari_pamsnet.c	Sun Oct 31 19:21:27 1999
@@ -779,7 +779,7 @@
 
 			/* Malloc up new buffer.
 			 */
-			skb = alloc_skb(pkt_len, GFP_ATOMIC);
+			skb = alloc_skb(pkt_len, GFP_NUCLEONIC);
 			if (skb == NULL) {
 				printk("%s: Memory squeeze, dropping packet.\n",
 					dev->name);
Only in linux/drivers/net: atari_pamsnet.c~
diff -ru linux-2.2.13pre17/drivers/net/cs89x0.c linux/drivers/net/cs89x0.c
--- linux-2.2.13pre17/drivers/net/cs89x0.c	Wed Oct 13 20:36:06 1999
+++ linux/drivers/net/cs89x0.c	Sun Oct 31 19:21:31 1999
@@ -887,7 +887,7 @@
 	}
 
 	/* Malloc up new buffer. */
-	skb = alloc_skb(length, GFP_ATOMIC);
+	skb = alloc_skb(length, GFP_NUCLEONIC);
 	if (skb == NULL) {
 		printk("%s: Memory squeeze, dropping packet.\n", dev->name);
 		lp->stats.rx_dropped++;
Only in linux/drivers/net: cs89x0.c~
diff -ru linux-2.2.13pre17/drivers/net/dmfe.c linux/drivers/net/dmfe.c
--- linux-2.2.13pre17/drivers/net/dmfe.c	Wed Oct 13 20:51:23 1999
+++ linux/drivers/net/dmfe.c	Sun Oct 31 19:21:35 1999
@@ -1149,7 +1149,7 @@
 	rxptr = db->rx_insert_ptr;
 
 	while (db->rx_avail_cnt < RX_DESC_CNT) {
-		if ((skb = alloc_skb(RX_ALLOC_SIZE, GFP_ATOMIC)) == NULL)
+		if ((skb = alloc_skb(RX_ALLOC_SIZE, GFP_NUCLEONIC)) == NULL)
 			break;
 		rxptr->rx_skb_ptr = (u32) skb;
 		rxptr->rdes2 = virt_to_bus(skb->tail);
Only in linux/drivers/net: dmfe.c~
diff -ru linux-2.2.13pre17/drivers/net/eepro100.c linux/drivers/net/eepro100.c
--- linux-2.2.13pre17/drivers/net/eepro100.c	Wed Oct 13 20:51:23 1999
+++ linux/drivers/net/eepro100.c	Sun Oct 31 19:21:40 1999
@@ -1512,7 +1512,7 @@
 				kfree(sp->mc_setup_frm);
 			sp->mc_setup_busy = 0;
 			sp->mc_setup_frm_len = 10 + multicast_filter_limit*6;
-			sp->mc_setup_frm = kmalloc(sp->mc_setup_frm_len, GFP_ATOMIC);
+			sp->mc_setup_frm = kmalloc(sp->mc_setup_frm_len, GFP_NUCLEONIC);
 			if (sp->mc_setup_frm == NULL) {
 				printk(KERN_ERR "%s: Failed to allocate a setup frame.\n",
 					   dev->name);
Only in linux/drivers/net: eepro100.c~
diff -ru linux-2.2.13pre17/drivers/net/ethertap.c linux/drivers/net/ethertap.c
--- linux-2.2.13pre17/drivers/net/ethertap.c	Tue May 11 15:24:31 1999
+++ linux/drivers/net/ethertap.c	Sun Oct 31 19:21:48 1999
@@ -196,7 +196,7 @@
 	/* Make the same thing, which loopback does. */
 	if (skb_shared(skb)) {
 	  	struct sk_buff *skb2 = skb;
-	  	skb = skb_clone(skb, GFP_ATOMIC);	/* Clone the buffer */
+	  	skb = skb_clone(skb, GFP_NUCLEONIC);	/* Clone the buffer */
 	  	if (skb==NULL) {
 			dev_kfree_skb(skb2);
 			return 0;
@@ -209,10 +209,10 @@
 	lp->stats.tx_packets++;
 
 #ifndef CONFIG_ETHERTAP_MC
-	netlink_broadcast(lp->nl, skb, 0, ~0, GFP_ATOMIC);
+	netlink_broadcast(lp->nl, skb, 0, ~0, GFP_NUCLEONIC);
 #else
 	if (dev->flags&IFF_NOARP) {
-		netlink_broadcast(lp->nl, skb, 0, ~0, GFP_ATOMIC);
+		netlink_broadcast(lp->nl, skb, 0, ~0, GFP_NUCLEONIC);
 		return 0;
 	}
 
@@ -222,7 +222,7 @@
 		memcpy(&pid, eth->h_dest+2, 4);
 		netlink_unicast(lp->nl, skb, ntohl(pid), MSG_DONTWAIT);
 	} else
-		netlink_broadcast(lp->nl, skb, 0, ethertap_mc_hash(eth->h_dest), GFP_ATOMIC);
+		netlink_broadcast(lp->nl, skb, 0, ethertap_mc_hash(eth->h_dest), GFP_NUCLEONIC);
 #endif
 	return 0;
 }
Only in linux/drivers/net: ethertap.c~
diff -ru linux-2.2.13pre17/drivers/net/lance.c linux/drivers/net/lance.c
--- linux-2.2.13pre17/drivers/net/lance.c	Wed Oct 13 20:36:07 1999
+++ linux/drivers/net/lance.c	Sun Oct 31 19:21:53 1999
@@ -842,7 +842,7 @@
 	if (must_reinit ||
 		(chip_table[lp->chip_version].flags & LANCE_MUST_REINIT_RING)) {
 		lance_purge_tx_ring(dev);
-		lance_init_ring(dev, GFP_ATOMIC);
+		lance_init_ring(dev, GFP_NUCLEONIC);
 	}
 	outw(0x0000,    dev->base_addr + LANCE_ADDR);
 	outw(csr0_bits, dev->base_addr + LANCE_DATA);
Only in linux/drivers/net: lance.c~
diff -ru linux-2.2.13pre17/drivers/net/loopback.c linux/drivers/net/loopback.c
--- linux-2.2.13pre17/drivers/net/loopback.c	Fri Jun 12 05:52:33 1998
+++ linux/drivers/net/loopback.c	Sun Oct 31 19:21:58 1999
@@ -77,7 +77,7 @@
 	if(atomic_read(&skb->users) != 1)
 	{
 	  	struct sk_buff *skb2=skb;
-	  	skb=skb_clone(skb, GFP_ATOMIC);		/* Clone the buffer */
+	  	skb=skb_clone(skb, GFP_NUCLEONIC);		/* Clone the buffer */
 	  	if(skb==NULL) {
 			kfree_skb(skb2);
 			return 0;
Only in linux/drivers/net: loopback.c~
diff -ru linux-2.2.13pre17/drivers/net/myri_sbus.c linux/drivers/net/myri_sbus.c
--- linux-2.2.13pre17/drivers/net/myri_sbus.c	Fri Mar 26 21:57:41 1999
+++ linux/drivers/net/myri_sbus.c	Sun Oct 31 19:22:04 1999
@@ -266,7 +266,7 @@
 	int i;
 
 	if(from_irq || in_interrupt())
-		gfp_flags = GFP_ATOMIC;
+		gfp_flags = GFP_NUCLEONIC;
 
 	myri_clean_rings(mp);
 	for(i = 0; i < RX_RING_SIZE; i++) {
@@ -448,7 +448,7 @@
 			struct sk_buff *new_skb;
 
 			DRX(("BIGBUFF "));
-			new_skb = myri_alloc_skb(RX_ALLOC_SIZE, GFP_ATOMIC);
+			new_skb = myri_alloc_skb(RX_ALLOC_SIZE, GFP_NUCLEONIC);
 			if(!new_skb) {
 				DRX(("skb_alloc(FAILED) "));
 				goto drop_it;
Only in linux/drivers/net: myri_sbus.c~
diff -ru linux-2.2.13pre17/drivers/net/ni65.c linux/drivers/net/ni65.c
--- linux-2.2.13pre17/drivers/net/ni65.c	Tue Jun  8 17:27:27 1999
+++ linux/drivers/net/ni65.c	Sun Oct 31 19:22:08 1999
@@ -1029,7 +1029,7 @@
 		else if( (len = (rmdp->mlen & 0x0fff) - 4) >= 60)
 		{
 #ifdef RCV_VIA_SKB
-			struct sk_buff *skb = alloc_skb(R_BUF_SIZE+2+16,GFP_ATOMIC);
+			struct sk_buff *skb = alloc_skb(R_BUF_SIZE+2+16,GFP_NUCLEONIC);
 			if (skb)
 				skb_reserve(skb,16);
 #else
Only in linux/drivers/net: ni65.c~
diff -ru linux-2.2.13pre17/drivers/net/ppp.c linux/drivers/net/ppp.c
--- linux-2.2.13pre17/drivers/net/ppp.c	Wed Oct 13 20:51:23 1999
+++ linux/drivers/net/ppp.c	Sun Oct 31 19:22:15 1999
@@ -2461,7 +2461,7 @@
 		int new_count;
 
 		/* Allocate an skb for the compressed frame. */
-		new_skb = alloc_skb(ppp->mtu + PPP_HDRLEN, GFP_ATOMIC);
+		new_skb = alloc_skb(ppp->mtu + PPP_HDRLEN, GFP_NUCLEONIC);
 		if (new_skb == NULL) {
 			printk(KERN_ERR "ppp_send_frame: no memory\n");
 			kfree_skb(skb);
@@ -2514,7 +2514,7 @@
 	struct sk_buff *new_skb;
 	int len, proto;
 
-	new_skb = alloc_skb(skb->len, GFP_ATOMIC);
+	new_skb = alloc_skb(skb->len, GFP_NUCLEONIC);
 	if (new_skb == NULL) {
 		printk(KERN_ERR "ppp: no memory for vj compression\n");
 		return skb;
@@ -2731,7 +2731,7 @@
 	if (skb_headroom(skb) < PPP_HDRLEN) {
 		struct sk_buff *new_skb;
 
-		new_skb = alloc_skb(skb->len + PPP_HDRLEN, GFP_ATOMIC);
+		new_skb = alloc_skb(skb->len + PPP_HDRLEN, GFP_NUCLEONIC);
 		if (new_skb == NULL) {
 			printk(KERN_ERR "%s: skb hdr alloc failed\n",
 			       ppp->name);
Only in linux/drivers/net: ppp.c~
diff -ru linux-2.2.13pre17/drivers/net/ppp_deflate.c linux/drivers/net/ppp_deflate.c
--- linux-2.2.13pre17/drivers/net/ppp_deflate.c	Thu Mar 11 00:51:35 1999
+++ linux/drivers/net/ppp_deflate.c	Sun Oct 31 19:22:21 1999
@@ -135,7 +135,7 @@
 	unsigned nbytes;
 
 	nbytes = items * size + sizeof(*hdr);
-	hdr = kmalloc(nbytes, GFP_ATOMIC);
+	hdr = kmalloc(nbytes, GFP_NUCLEONIC);
 	if (hdr == 0)
 		return 0;
 	hdr->valloced = 0;
Only in linux/drivers/net: ppp_deflate.c~
diff -ru linux-2.2.13pre17/drivers/net/rcpci45.c linux/drivers/net/rcpci45.c
--- linux-2.2.13pre17/drivers/net/rcpci45.c	Mon Apr 12 23:18:27 1999
+++ linux/drivers/net/rcpci45.c	Sun Oct 31 19:22:31 1999
@@ -337,7 +337,7 @@
      */
 
 #ifdef MODULE
-    dev = (struct device *) kmalloc(dev_size, GFP_DMA | GFP_KERNEL |GFP_ATOMIC);
+    dev = (struct device *) kmalloc(dev_size, GFP_DMA | GFP_KERNEL |GFP_NUCLEONIC);
     if (!dev)
     {
         printk("rc: unable to kmalloc dev\n");
@@ -350,7 +350,7 @@
     dev->priv = (void *)(((long)dev + sizeof(struct device) + 15) & ~15);
 #else
     dev->priv = 0;
-    dev->priv = (struct device *) kmalloc(dev_size, GFP_DMA | GFP_KERNEL |GFP_ATOMIC);
+    dev->priv = (struct device *) kmalloc(dev_size, GFP_DMA | GFP_KERNEL |GFP_NUCLEONIC);
     if (!dev->priv)
     {
         printk("rc: unable to kmalloc private area\n");
@@ -1374,7 +1374,7 @@
         numBuffers = 32;
     }
     
-    p = (PU32) kmalloc(sizeof(U32) + numBuffers*sizeof(singleB), GFP_ATOMIC);
+    p = (PU32) kmalloc(sizeof(U32) + numBuffers*sizeof(singleB), GFP_NUCLEONIC);
 
 #ifdef RCDEBUG
     printk("rc: TCB = 0x%x\n", (uint)p);
Only in linux/drivers/net: rcpci45.c~
diff -ru linux-2.2.13pre17/drivers/net/rrunner.c linux/drivers/net/rrunner.c
--- linux-2.2.13pre17/drivers/net/rrunner.c	Sun Apr 25 00:51:48 1999
+++ linux/drivers/net/rrunner.c	Sun Oct 31 19:22:37 1999
@@ -656,7 +656,7 @@
 		struct sk_buff *skb;
 
 		rrpriv->rx_ring[i].mode = 0;
-		skb = alloc_skb(dev->mtu + HIPPI_HLEN, GFP_ATOMIC);
+		skb = alloc_skb(dev->mtu + HIPPI_HLEN, GFP_NUCLEONIC);
 		rrpriv->rx_skbuff[i] = skb;
 		/*
 		 * Sanity test to see if we conflict with the DMA
@@ -812,7 +812,7 @@
 			struct sk_buff *skb;
 
 			if (pkt_len < PKT_COPY_THRESHOLD) {
-				skb = alloc_skb(pkt_len, GFP_ATOMIC);
+				skb = alloc_skb(pkt_len, GFP_NUCLEONIC);
 				if (skb == NULL){
 					printk("%s: Out of memory deferring "
 					       "packet\n", dev->name);
@@ -826,7 +826,7 @@
 				struct sk_buff *newskb;
 
 				newskb = alloc_skb(dev->mtu + HIPPI_HLEN,
-						   GFP_ATOMIC);
+						   GFP_NUCLEONIC);
 				if (newskb){
 					skb = rrpriv->rx_skbuff[index];
 					skb_put(skb, pkt_len);
Only in linux/drivers/net: rrunner.c~
diff -ru linux-2.2.13pre17/drivers/net/sb1000.c linux/drivers/net/sb1000.c
--- linux-2.2.13pre17/drivers/net/sb1000.c	Wed Oct 13 20:51:23 1999
+++ linux/drivers/net/sb1000.c	Sun Oct 31 19:22:43 1999
@@ -874,7 +874,7 @@
 		lp->rx_dlen[ns] = dlen;
 		/* compute size to allocate for datagram */
 		skbsize = dlen + FrameSize;
-		if ((skb = alloc_skb(skbsize, GFP_ATOMIC)) == NULL) {
+		if ((skb = alloc_skb(skbsize, GFP_NUCLEONIC)) == NULL) {
 			if (sb1000_debug > 1)
 				printk(KERN_WARNING "%s: can't allocate %d bytes long "
 					"skbuff\n", dev->name, skbsize);
Only in linux/drivers/net: sb1000.c~
diff -ru linux-2.2.13pre17/drivers/net/sdla_fr.c linux/drivers/net/sdla_fr.c
--- linux-2.2.13pre17/drivers/net/sdla_fr.c	Mon Jan  4 19:37:29 1999
+++ linux/drivers/net/sdla_fr.c	Sun Oct 31 19:22:48 1999
@@ -2471,7 +2471,7 @@
 	int udp_mgmt_req_valid = 1;
 	sendpacket = skb->data;
 	memcpy(&buf2, &card->wandev.udp_port, 2);
-	if ((data = kmalloc(2000, GFP_ATOMIC)) == NULL) 
+	if ((data = kmalloc(2000, GFP_NUCLEONIC)) == NULL) 
 	{
 		printk(KERN_INFO
 		       "%s: Error allocating memory for UDP management cmnd 0x%02X",
@@ -2831,7 +2831,7 @@
 	int err;
 	sendpacket = skb->data;
 	memcpy(&buf2, &card->wandev.udp_port, 2);
-	if ((data = kmalloc(2000, GFP_ATOMIC)) == NULL) 
+	if ((data = kmalloc(2000, GFP_NUCLEONIC)) == NULL) 
 	{
 		printk(KERN_INFO
 		       "%s: Error allocating memory for UDP DRIVER STATS cmnd0x%02X"
Only in linux/drivers/net: sdla_fr.c~
diff -ru linux-2.2.13pre17/drivers/net/sdla_ppp.c linux/drivers/net/sdla_ppp.c
--- linux-2.2.13pre17/drivers/net/sdla_ppp.c	Mon Jan  4 19:37:29 1999
+++ linux/drivers/net/sdla_ppp.c	Sun Oct 31 19:22:53 1999
@@ -1603,7 +1603,7 @@
 	int err;
 	sendpacket = skb->data;
 	memcpy(&buf2, &card->wandev.udp_port, 2);
-	if ((data = kmalloc(2000, GFP_ATOMIC)) == NULL) {
+	if ((data = kmalloc(2000, GFP_NUCLEONIC)) == NULL) {
 		printk(KERN_INFO
 		       "%s: Error allocating memory for UDP DRIVER STATS cmnd0x%02X"
 		       ,card->devname, data[45]);
@@ -1793,7 +1793,7 @@
 	int err;
 	sendpacket = skb->data;
 	memcpy(&buf2, &card->wandev.udp_port, 2);
-	if ((data = kmalloc(2000, GFP_ATOMIC)) == NULL) {
+	if ((data = kmalloc(2000, GFP_NUCLEONIC)) == NULL) {
 		printk(KERN_INFO
 		       "%s: Error allocating memory for UDP management cmnd0x%02X"
 		       ,card->devname, data[45]);
Only in linux/drivers/net: sdla_ppp.c~
diff -ru linux-2.2.13pre17/drivers/net/sdla_x25.c linux/drivers/net/sdla_x25.c
--- linux-2.2.13pre17/drivers/net/sdla_x25.c	Mon Jan  4 19:37:29 1999
+++ linux/drivers/net/sdla_x25.c	Sun Oct 31 19:22:58 1999
@@ -1629,7 +1629,7 @@
 	unsigned dlen = ((TX25Mbox*)card->mbox)->cmd.length;
 	TX25Mbox* mb;
 
-	mb = kmalloc(sizeof(TX25Mbox) + dlen, GFP_ATOMIC);
+	mb = kmalloc(sizeof(TX25Mbox) + dlen, GFP_NUCLEONIC);
 	if (mb == NULL)
 	{
 		printk(KERN_ERR "%s: x25_error() out of memory!\n",
@@ -1771,7 +1771,7 @@
 	}
 
 	/* Parse call request data */
-	info = kmalloc(sizeof(x25_call_info_t), GFP_ATOMIC);
+	info = kmalloc(sizeof(x25_call_info_t), GFP_NUCLEONIC);
 	if (info == NULL)
 	{
 		printk(KERN_ERR
Only in linux/drivers/net: sdla_x25.c~
diff -ru linux-2.2.13pre17/drivers/net/shaper.c linux/drivers/net/shaper.c
--- linux-2.2.13pre17/drivers/net/shaper.c	Wed Oct 13 20:36:07 1999
+++ linux/drivers/net/shaper.c	Sun Oct 31 19:23:03 1999
@@ -258,7 +258,7 @@
  
 static void shaper_queue_xmit(struct shaper *shaper, struct sk_buff *skb)
 {
-	struct sk_buff *newskb=skb_clone(skb, GFP_ATOMIC);
+	struct sk_buff *newskb=skb_clone(skb, GFP_NUCLEONIC);
 	if(sh_debug)
 		printk("Kick frame on %p\n",newskb);
 	if(newskb)
Only in linux/drivers/net: shaper.c~
diff -ru linux-2.2.13pre17/drivers/net/slip.c linux/drivers/net/slip.c
--- linux-2.2.13pre17/drivers/net/slip.c	Wed Oct 13 20:51:24 1999
+++ linux/drivers/net/slip.c	Sun Oct 31 19:23:09 1999
@@ -248,10 +248,10 @@
 	if (len < 576 * 2)
 		len = 576 * 2;
 
-	xbuff = (unsigned char *) kmalloc (len + 4, GFP_ATOMIC);
-	rbuff = (unsigned char *) kmalloc (len + 4, GFP_ATOMIC);
+	xbuff = (unsigned char *) kmalloc (len + 4, GFP_NUCLEONIC);
+	rbuff = (unsigned char *) kmalloc (len + 4, GFP_NUCLEONIC);
 #ifdef SL_INCLUDE_CSLIP
-	cbuff = (unsigned char *) kmalloc (len + 4, GFP_ATOMIC);
+	cbuff = (unsigned char *) kmalloc (len + 4, GFP_NUCLEONIC);
 #endif
 
 
Only in linux/drivers/net: slip.c~
diff -ru linux-2.2.13pre17/drivers/net/smc9194.c linux/drivers/net/smc9194.c
--- linux-2.2.13pre17/drivers/net/smc9194.c	Thu Mar 11 00:51:35 1999
+++ linux/drivers/net/smc9194.c	Sun Oct 31 19:23:14 1999
@@ -1463,7 +1463,7 @@
 			lp->stats.multicast++;
 
 #ifdef SUPPORT_OLD_KERNEL
-		skb = alloc_skb( packet_length + 5, GFP_ATOMIC );
+		skb = alloc_skb( packet_length + 5, GFP_NUCLEONIC );
 #else
 		skb = dev_alloc_skb( packet_length + 5);
 #endif
Only in linux/drivers/net: smc9194.c~
diff -ru linux-2.2.13pre17/drivers/net/strip.c linux/drivers/net/strip.c
--- linux-2.2.13pre17/drivers/net/strip.c	Sun Nov  8 21:48:06 1998
+++ linux/drivers/net/strip.c	Sun Oct 31 19:23:22 1999
@@ -935,9 +935,9 @@
     struct device *dev = &strip_info->dev;
     int sx_size    = MAX(STRIP_ENCAP_SIZE(MAX_RECV_MTU), 4096);
     int tx_size    = STRIP_ENCAP_SIZE(dev->mtu) + MaxCommandStringLength;
-    __u8 *r = kmalloc(MAX_RECV_MTU, GFP_ATOMIC);
-    __u8 *s = kmalloc(sx_size,      GFP_ATOMIC);
-    __u8 *t = kmalloc(tx_size,      GFP_ATOMIC);
+    __u8 *r = kmalloc(MAX_RECV_MTU, GFP_NUCLEONIC);
+    __u8 *s = kmalloc(sx_size,      GFP_NUCLEONIC);
+    __u8 *t = kmalloc(tx_size,      GFP_NUCLEONIC);
     if (r && s && t)
     {
         strip_info->rx_buff = r;
Only in linux/drivers/net: strip.c~
diff -ru linux-2.2.13pre17/drivers/net/sunbmac.c linux/drivers/net/sunbmac.c
--- linux-2.2.13pre17/drivers/net/sunbmac.c	Tue Mar 16 00:11:30 1999
+++ linux/drivers/net/sunbmac.c	Sun Oct 31 19:23:34 1999
@@ -204,7 +204,7 @@
 	int i, gfp_flags = GFP_KERNEL;
 
 	if(from_irq || in_interrupt())
-		gfp_flags = GFP_ATOMIC;
+		gfp_flags = GFP_NUCLEONIC;
 
 	bp->rx_new = bp->rx_old = bp->tx_new = bp->tx_old = 0;
 
@@ -850,7 +850,7 @@
 			struct sk_buff *new_skb;
 
 			/* Now refill the entry, if we can. */
-			new_skb = big_mac_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_ATOMIC);
+			new_skb = big_mac_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_NUCLEONIC);
 			if(!new_skb) {
 				drops++;
 				goto drop_it;
@@ -1090,7 +1090,7 @@
 #ifdef NEED_DMA_SYNCHRONIZATION
 #ifdef __sparc_v9__
 	if ((unsigned long) (skb->data + skb->len) >= MAX_DMA_ADDRESS) {
-		struct sk_buff *new_skb = skb_copy(skb, GFP_DMA | GFP_ATOMIC);
+		struct sk_buff *new_skb = skb_copy(skb, GFP_DMA | GFP_NUCLEONIC);
 		if(!new_skb)
 			return 1;
 		dev_kfree_skb(skb);
Only in linux/drivers/net: sunbmac.c~
diff -ru linux-2.2.13pre17/drivers/net/sunhme.c linux/drivers/net/sunhme.c
--- linux-2.2.13pre17/drivers/net/sunhme.c	Wed Oct 13 20:51:24 1999
+++ linux/drivers/net/sunhme.c	Sun Oct 31 19:23:41 1999
@@ -1050,7 +1050,7 @@
 	int i, gfp_flags = GFP_KERNEL;
 
 	if(from_irq || in_interrupt())
-		gfp_flags = GFP_ATOMIC;
+		gfp_flags = GFP_NUCLEONIC;
 
 	HMD(("happy_meal_init_rings: counters to zero, "));
 	hp->rx_new = hp->rx_old = hp->tx_new = hp->tx_old = 0;
@@ -1887,7 +1887,7 @@
 
 			/* Now refill the entry, if we can. */
 			new_skb = happy_meal_alloc_skb(RX_BUF_ALLOC_SIZE,
-						       (GFP_DMA|GFP_ATOMIC));
+						       (GFP_DMA|GFP_NUCLEONIC));
 			if(!new_skb) {
 				drops++;
 				goto drop_it;
@@ -1999,7 +1999,7 @@
 
 			/* Now refill the entry, if we can. */
 			new_skb = happy_meal_alloc_skb(RX_BUF_ALLOC_SIZE,
-						       (GFP_DMA|GFP_ATOMIC));
+						       (GFP_DMA|GFP_NUCLEONIC));
 			if(!new_skb) {
 				drops++;
 				goto drop_it;
@@ -2175,7 +2175,7 @@
 
 			/* Now refill the entry, if we can. */
 			new_skb = happy_meal_alloc_skb(RX_BUF_ALLOC_SIZE,
-						       (GFP_DMA | GFP_ATOMIC));
+						       (GFP_DMA | GFP_NUCLEONIC));
 			if(!new_skb) {
 				drops++;
 				goto drop_it;
@@ -2589,7 +2589,7 @@
 	}
 #ifdef __sparc_v9__
 	if ((unsigned long)(skb->data + skb->len) >= MAX_DMA_ADDRESS) {
-		struct sk_buff *new_skb = skb_copy(skb, GFP_DMA | GFP_ATOMIC);
+		struct sk_buff *new_skb = skb_copy(skb, GFP_DMA | GFP_NUCLEONIC);
 		if (!new_skb)
 			return 1;
 		dev_kfree_skb(skb);
Only in linux/drivers/net: sunhme.c~
diff -ru linux-2.2.13pre17/drivers/net/syncppp.c linux/drivers/net/syncppp.c
--- linux-2.2.13pre17/drivers/net/syncppp.c	Wed Oct 13 20:51:24 1999
+++ linux/drivers/net/syncppp.c	Sun Oct 31 19:23:46 1999
@@ -740,7 +740,7 @@
 	struct device *dev = sp->pp_if;
 
 	skb=alloc_skb(dev->hard_header_len+PPP_HEADER_LEN+LCP_HEADER_LEN+len,
-		GFP_ATOMIC);
+		GFP_NUCLEONIC);
 	if (skb==NULL)
 		return;
 
@@ -790,7 +790,7 @@
 	u32 t = jiffies * 1000/HZ;
 
 	skb=alloc_skb(dev->hard_header_len+PPP_HEADER_LEN+CISCO_PACKET_LEN,
-		GFP_ATOMIC);
+		GFP_NUCLEONIC);
 
 	if(skb==NULL)
 		return;
@@ -998,7 +998,7 @@
 	int rlen;
 
 	len -= 4;
-	buf = r = kmalloc (len, GFP_ATOMIC);
+	buf = r = kmalloc (len, GFP_NUCLEONIC);
 	if (! buf)
 		return (0);
 
Only in linux/drivers/net: syncppp.c~
diff -ru linux-2.2.13pre17/drivers/net/tulip.c linux/drivers/net/tulip.c
--- linux-2.2.13pre17/drivers/net/tulip.c	Wed Oct 13 20:36:08 1999
+++ linux/drivers/net/tulip.c	Sun Oct 31 19:23:52 1999
@@ -91,7 +91,7 @@
 
 #if defined (LINUX_VERSION_CODE) && LINUX_VERSION_CODE < 0x10300
 #define RUN_AT(x) (x)			/* What to put in timer->expires.  */
-#define DEV_ALLOC_SKB(len) alloc_skb(len, GFP_ATOMIC)
+#define DEV_ALLOC_SKB(len) alloc_skb(len, GFP_NUCLEONIC)
 #define virt_to_bus(addr)  ((unsigned long)addr)
 #define bus_to_virt(addr) ((void*)addr)
 
Only in linux/drivers/net: tulip.c~
diff -ru linux-2.2.13pre17/drivers/net/wavelan.c linux/drivers/net/wavelan.c
--- linux-2.2.13pre17/drivers/net/wavelan.c	Wed Oct 13 20:51:24 1999
+++ linux/drivers/net/wavelan.c	Sun Oct 31 19:23:56 1999
@@ -2413,7 +2413,7 @@
   if((skb = dev_alloc_skb(sksize)) == (struct sk_buff *) NULL)
     {
 #ifdef DEBUG_RX_ERROR
-      printk(KERN_INFO "%s: wv_packet_read(): could not alloc_skb(%d, GFP_ATOMIC).\n",
+      printk(KERN_INFO "%s: wv_packet_read(): could not alloc_skb(%d, GFP_NUCLEONIC).\n",
 	     dev->name, sksize);
 #endif
       lp->stats.rx_dropped++;
Only in linux/drivers/net: wavelan.c~
diff -ru linux-2.2.13pre17/drivers/net/x25_asy.c linux/drivers/net/x25_asy.c
--- linux-2.2.13pre17/drivers/net/x25_asy.c	Sat Feb 21 02:28:22 1998
+++ linux/drivers/net/x25_asy.c	Sun Oct 31 19:24:07 1999
@@ -146,8 +146,8 @@
 
 	len = dev->mtu * 2;
 
-	xbuff = (unsigned char *) kmalloc (len + 4, GFP_ATOMIC);
-	rbuff = (unsigned char *) kmalloc (len + 4, GFP_ATOMIC);
+	xbuff = (unsigned char *) kmalloc (len + 4, GFP_NUCLEONIC);
+	rbuff = (unsigned char *) kmalloc (len + 4, GFP_NUCLEONIC);
 
 	if (xbuff == NULL || rbuff == NULL)  
 	{
Only in linux/drivers/net: x25_asy.c~
diff -ru linux-2.2.13pre17/include/asm-i386/socket.h linux/include/asm-i386/socket.h
--- linux-2.2.13pre17/include/asm-i386/socket.h	Wed Oct 13 20:36:19 1999
+++ linux/include/asm-i386/socket.h	Sun Oct 31 18:53:02 1999
@@ -54,4 +54,7 @@
 					/* user level.			*/
 #endif					
 
+/* VM via network */
+#define SO_SWAPPING	255 /* Mmmh. ??? */
+
 #endif /* _ASM_SOCKET_H */
Only in linux/include/asm-i386: socket.h.orig
diff -ru linux-2.2.13pre17/include/linux/mm.h linux/include/linux/mm.h
--- linux-2.2.13pre17/include/linux/mm.h	Wed Oct 13 20:36:44 1999
+++ linux/include/linux/mm.h	Sun Oct 31 19:09:28 1999
@@ -335,8 +335,15 @@
 
 #define __GFP_DMA	0x80
 
+#define GFP_WAIT	(__GFP_WAIT)
 #define GFP_BUFFER	(__GFP_LOW | __GFP_WAIT)
-#define GFP_ATOMIC	(__GFP_HIGH)
+#ifdef CONFIG_SWAP_VIA_NETWORK
+#  define GFP_ATOMIC	(__GFP_MED)
+#  define GFP_NUCLEONIC	(__GFP_HIGH)
+#else
+#  define GFP_ATOMIC	(__GFP_HIGH)
+#  define GFP_NUCLEONIC	(__GFP_HIGH)
+#endif
 #define GFP_USER	(__GFP_LOW | __GFP_WAIT | __GFP_IO)
 #define GFP_KERNEL	(__GFP_MED | __GFP_WAIT | __GFP_IO)
 #define GFP_NFS		(__GFP_HIGH | __GFP_WAIT | __GFP_IO)
Only in linux/include/linux: mm.h.orig
Only in linux/include/linux: mm.h.rej
Only in linux/include/linux: mm.h~
diff -ru linux-2.2.13pre17/include/linux/netdevice.h linux/include/linux/netdevice.h
--- linux-2.2.13pre17/include/linux/netdevice.h	Wed Oct 13 20:36:44 1999
+++ linux/include/linux/netdevice.h	Sun Oct 31 18:53:03 1999
@@ -314,6 +314,13 @@
 #endif
 };
 
+/* Note: swappable is a hack s.t. I don`t need to change all of the
+ * high level handlers. If swappable is set to 0, all packets are
+ * discarded when nr_free_pages falls below the reserved_for_swap
+ * threshold. If swappable is set, then p->func must handle low memory
+ * cases when delivering the packet to the socket layer. (using
+ * (struct sock *)->swapping in net/sock.h)
+ */
 
 struct packet_type 
 {
@@ -323,6 +330,9 @@
 					 struct packet_type *);
 	void			*data;	/* Private to the packet type		*/
 	struct packet_type	*next;
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	int			swappable:1;
+#endif
 };
 
 
Only in linux/include/linux: netdevice.h.orig
diff -ru linux-2.2.13pre17/include/linux/skbuff.h linux/include/linux/skbuff.h
--- linux-2.2.13pre17/include/linux/skbuff.h	Thu May 13 17:33:17 1999
+++ linux/include/linux/skbuff.h	Sun Oct 31 18:53:03 1999
@@ -552,7 +552,7 @@
 {
 	struct sk_buff *skb;
 
-	skb = alloc_skb(length+16, GFP_ATOMIC);
+	skb = alloc_skb(length+16, GFP_NUCLEONIC);
 	if (skb)
 		skb_reserve(skb,16);
 	return skb;
Only in linux/include/linux: skbuff.h.orig
diff -ru linux-2.2.13pre17/include/linux/slab.h linux/include/linux/slab.h
--- linux-2.2.13pre17/include/linux/slab.h	Tue May 11 17:35:46 1999
+++ linux/include/linux/slab.h	Sun Oct 31 18:53:03 1999
@@ -15,8 +15,10 @@
 #include	<asm/cache.h>
 
 /* flags for kmem_cache_alloc() */
+#define SLAB_WAIT		GFP_WAIT
 #define	SLAB_BUFFER		GFP_BUFFER
 #define	SLAB_ATOMIC		GFP_ATOMIC
+#define	SLAB_NUCLEONIC		GFP_NUCLEONIC
 #define	SLAB_USER		GFP_USER
 #define	SLAB_KERNEL		GFP_KERNEL
 #define	SLAB_NFS		GFP_NFS
@@ -38,6 +40,7 @@
 #if	0
 #define	SLAB_HIGH_PACK		0x00004000UL	/* XXX */
 #endif
+#define SLAB_LOW_GFP_ORDER	0x00008000UL	/* use as low a gfp order as possible */
 
 /* flags passed to a constructor func */
 #define	SLAB_CTOR_CONSTRUCTOR	0x001UL		/* if not set, then deconstructor */
diff -ru linux-2.2.13pre17/include/linux/sunrpc/debug.h linux/include/linux/sunrpc/debug.h
--- linux-2.2.13pre17/include/linux/sunrpc/debug.h	Tue May 11 17:35:44 1999
+++ linux/include/linux/sunrpc/debug.h	Sun Oct 31 18:53:03 1999
@@ -86,6 +86,7 @@
 	CTL_NFSDEBUG,
 	CTL_NFSDDEBUG,
 	CTL_NLMDEBUG,
+	CTL_RPCIOD,
 };
 
 #endif /* _LINUX_SUNRPC_DEBUG_H_ */
diff -ru linux-2.2.13pre17/include/linux/swapctl.h linux/include/linux/swapctl.h
--- linux-2.2.13pre17/include/linux/swapctl.h	Tue May 11 17:35:45 1999
+++ linux/include/linux/swapctl.h	Sun Oct 31 19:11:46 1999
@@ -19,6 +19,9 @@
 	unsigned int	min;
 	unsigned int	low;
 	unsigned int	high;
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	unsigned int    swap;
+#endif
 } freepages_v1;
 typedef freepages_v1 freepages_t;
 extern freepages_t freepages;
@@ -31,5 +34,15 @@
 } pager_daemon_v1;
 typedef pager_daemon_v1 pager_daemon_t;
 extern pager_daemon_t pager_daemon;
+
+#ifdef __KERNEL__       
+
+#ifdef CONFIG_SWAP_VIA_NETWORK
+extern int nr_free_pages;
+#define SWAP_LOWMEM (nr_free_pages <= freepages.swap)
+#endif
+
+#endif
+
 
 #endif /* _LINUX_SWAPCTL_H */
Only in linux/include/linux: swapctl.h.orig
Only in linux/include/linux: swapctl.h.rej
Only in linux/include/linux: swapctl.h~
diff -ru linux-2.2.13pre17/include/net/sock.h linux/include/net/sock.h
--- linux-2.2.13pre17/include/net/sock.h	Wed Oct 13 20:36:21 1999
+++ linux/include/net/sock.h	Sun Oct 31 19:13:04 1999
@@ -89,6 +89,10 @@
 #include <linux/filter.h>
 #endif
 
+#ifdef CONFIG_SWAP_VIA_NETWORK
+#include <linux/swapctl.h>
+#endif
+
 #include <asm/atomic.h>
 
 #define MIN_WRITE_SPACE	2048
@@ -408,7 +412,8 @@
 				destroy,
 				no_check,
 				broadcast,
-				bsdism;
+				bsdism,
+				swapping;
 	unsigned char		debug;
 	int			proc;
 	unsigned long	        lingertime;
@@ -859,6 +864,10 @@
 #ifdef CONFIG_FILTER
 	struct sk_filter *filter;
 #endif
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	if (!sk->swapping && SWAP_LOWMEM)
+		 return -ENOMEM;
+#endif
 	/* Cast skb->rcvbuf to unsigned... It's pointless, but reduces
 	   number of warnings when compiling with -W --ANK
 	 */
@@ -879,6 +888,14 @@
 
 extern __inline__ int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)
 {
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	if (!sk->swapping && SWAP_LOWMEM)
+		return -ENOMEM;
+#endif
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	if (!sk->swapping && SWAP_LOWMEM)
+		return -ENOMEM;
+#endif
 	/* Cast skb->rcvbuf to unsigned... It's pointless, but reduces
 	   number of warnings when compiling with -W --ANK
 	 */
Only in linux/include/net: sock.h.orig
Only in linux/include/net: sock.h.rej
Only in linux/include/net: sock.h~
diff -ru linux-2.2.13pre17/mm/page_alloc.c linux/mm/page_alloc.c
--- linux-2.2.13pre17/mm/page_alloc.c	Wed Oct 13 20:51:37 1999
+++ linux/mm/page_alloc.c	Sun Oct 31 19:03:09 1999
@@ -147,6 +147,18 @@
 		__free_pages(mem_map + map_nr, order);
 }
 
+#ifdef DEBUG_NETWORK_SWAPPING
+#define XYZZY_SWAP_HACK(map_nr, order)			\
+	if (!in_interrupt() &&				\
+	    ADDRESS((map_nr)) != 0UL &&			\
+	    (current->flags & PF_MEMALLOC)		\
+	    current->swapping) {			\
+		current->swap_pages += 1 << (order);	\
+	}
+#else
+#define XYZZY_SWAP_HACK(map_nr, order) while(0) {}
+#endif
+
 /*
  * Some ugly macros to speed up __get_free_pages()..
  */
@@ -166,6 +178,7 @@
 			area->count--; \
 			EXPAND(ret, map_nr, order, new_order, area); \
 			spin_unlock_irqrestore(&page_alloc_lock, flags); \
+			XYZZY_SWAP_HACK(map_nr, order); \
 			return ADDRESS(map_nr); \
 		} \
 		new_order++; area++; \
@@ -193,6 +206,25 @@
 	if (order >= NR_MEM_LISTS)
 		goto nopage;
 
+#ifdef DEBUG_NETWORK_SWAPPING
+	if (nr_free_pages <= freepages.swap) {
+		save_flags(flags);
+		cli();
+		printk("intr: %d, pid: %d, swp: %d, pri: %d, order: %d, free: %d\n",
+		in_interrupt(), current->pid, current->swapping, gfp_mask,
+		order, nr_free_pages);
+		/* show_mem(); */
+		restore_flags(flags);
+	}
+	if ((current->flags & PF_MEMALLOC) && (gfp_mask & __GFP_WAIT)) {
+		/*  prevent deadlock in network layer
+		 */
+		printk("Need priority override\n");
+		gfp_mask &= ~__GFP_WAIT;
+	}
+#endif
+
+
 #ifdef ATOMIC_MEMORY_DEBUGGING
 	if ((gfp_mask & __GFP_WAIT) && in_interrupt()) {
 		static int count = 0;
@@ -229,6 +261,10 @@
 		if (!freed && !(gfp_mask & (__GFP_MED | __GFP_HIGH)))
 			goto nopage;
 	}
+
+	if (SWAP_LOWMEM && !(gfp_mask & __GFP_HIGH))
+		goto nopage;
+
 ok_to_allocate:
 	spin_lock_irqsave(&page_alloc_lock, flags);
 	/* if it's not a dma request, try non-dma first */
@@ -263,8 +299,9 @@
 
 	spin_lock_irqsave(&page_alloc_lock, flags);
 	printk("Free pages:      %6dkB\n ( ",nr_free_pages<<(PAGE_SHIFT-10));
-	printk("Free: %d (%d %d %d)\n",
+	printk("Free: %d (%d %d %d %d)\n",
 		nr_free_pages,
+		freepages.swap,
 		freepages.min,
 		freepages.low,
 		freepages.high);
@@ -310,6 +347,7 @@
 		i = 10;
 	if (i > 256)
 		i = 256;
+	freepages.swap = i >> 1;
 	freepages.min = i;
 	freepages.low = i * 2;
 	freepages.high = i * 3;
Only in linux/mm: page_alloc.c.orig
Only in linux/mm: page_alloc.c.rej
Only in linux/mm: page_alloc.c~
diff -ru linux-2.2.13pre17/mm/slab.c linux/mm/slab.c
--- linux-2.2.13pre17/mm/slab.c	Tue Nov 24 17:21:12 1998
+++ linux/mm/slab.c	Sun Oct 31 18:53:03 1999
@@ -137,15 +137,16 @@
 #if	0
 #define	SLAB_C_MASK		(SLAB_DEBUG_FREE|SLAB_DEBUG_INITIAL|SLAB_RED_ZONE| \
 				 SLAB_POISON|SLAB_HWCACHE_ALIGN|SLAB_NO_REAP| \
-				 SLAB_HIGH_PACK)
+				 SLAB_HIGH_PACK|SLAB_LOW_GFP_ORDER)
 #endif
 #define	SLAB_C_MASK		(SLAB_DEBUG_FREE|SLAB_DEBUG_INITIAL|SLAB_RED_ZONE| \
-				 SLAB_POISON|SLAB_HWCACHE_ALIGN|SLAB_NO_REAP)
+				 SLAB_POISON|SLAB_HWCACHE_ALIGN|SLAB_NO_REAP| \
+				 SLAB_LOW_GFP_ORDER)
 #else
 #if	0
-#define	SLAB_C_MASK		(SLAB_HWCACHE_ALIGN|SLAB_NO_REAP|SLAB_HIGH_PACK)
+#define	SLAB_C_MASK		(SLAB_HWCACHE_ALIGN|SLAB_NO_REAP|SLAB_HIGH_PACK|SLAB_LOW_GFP_ORDER)
 #endif
-#define	SLAB_C_MASK		(SLAB_HWCACHE_ALIGN|SLAB_NO_REAP)
+#define	SLAB_C_MASK		(SLAB_HWCACHE_ALIGN|SLAB_NO_REAP|SLAB_LOW_GFP_ORDER)
 #endif	/* SLAB_DEBUG_SUPPORT */
 
 /* Slab management struct.
@@ -471,7 +472,7 @@
 			 * allow tighter packing of the smaller caches. */
 			if (!(sizes->cs_cachep =
 			      kmem_cache_create(*names++, sizes->cs_size,
-						0, SLAB_HWCACHE_ALIGN, NULL, NULL)))
+						0, SLAB_HWCACHE_ALIGN|SLAB_LOW_GFP_ORDER, NULL, NULL)))
 				goto panic_time;
 			if (!found) {
 				/* Inc off-slab bufctl limit until the ceiling is hit. */
@@ -869,9 +870,11 @@
 		/* Large num of objs is good, but v. large slabs are currently
 		 * bad for the gfp()s.
 		 */
-		if (cachep->c_num <= SLAB_MIN_OBJS_PER_SLAB) {
-			if (cachep->c_gfporder < slab_break_gfp_order)
-				goto next;
+		if (!(flags & SLAB_LOW_GFP_ORDER)) {
+			if (cachep->c_num <= SLAB_MIN_OBJS_PER_SLAB) {
+				if (cachep->c_gfporder < slab_break_gfp_order)
+					goto next;
+			}
 		}
 
 		/* Stop caches with small objs having a large num of pages. */
@@ -1159,7 +1162,7 @@
 	 * in kmem_cache_alloc().  If a caller is slightly mis-behaving they
 	 * will eventually be caught here (where it matters).
 	 */
-	if (in_interrupt() && (flags & SLAB_LEVEL_MASK) != SLAB_ATOMIC) {
+	if (in_interrupt() && (flags & SLAB_WAIT)) {
 		printk(KERN_ERR "kmem_grow: Called nonatomically from int - %s\n",
 		       cachep->c_name);
 		flags &= ~SLAB_LEVEL_MASK;
Only in linux/mm: slab.c.orig
Only in linux/mm: slab.c.rej
diff -ru linux-2.2.13pre17/mm/swap.c linux/mm/swap.c
--- linux-2.2.13pre17/mm/swap.c	Sat Jan  9 06:54:16 1999
+++ linux/mm/swap.c	Sun Oct 31 18:53:03 1999
@@ -36,7 +36,10 @@
 freepages_t freepages = {
 	48,	/* freepages.min */
 	96,	/* freepages.low */
-	144	/* freepages.high */
+	144,	/* freepages.high */
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	24	/* freepages.swap */
+#endif
 };
 
 /* How many pages do we try to swap or page in/out together? */
Only in linux/mm: swap.c.orig
diff -ru linux-2.2.13pre17/net/Config.in linux/net/Config.in
--- linux-2.2.13pre17/net/Config.in	Thu Feb 25 18:46:47 1999
+++ linux/net/Config.in	Sun Oct 31 18:53:03 1999
@@ -11,6 +11,7 @@
 fi
 bool 'Network firewalls' CONFIG_FIREWALL
 bool 'Socket Filtering'  CONFIG_FILTER
+bool 'Swapping via network' CONFIG_SWAP_VIA_NETWORK
 tristate 'Unix domain sockets' CONFIG_UNIX
 bool 'TCP/IP networking' CONFIG_INET
 if [ "$CONFIG_INET" = "y" ]; then
Only in linux/net: Config.in.orig
diff -ru linux-2.2.13pre17/net/core/dev.c linux/net/core/dev.c
--- linux-2.2.13pre17/net/core/dev.c	Wed Oct 13 20:51:37 1999
+++ linux/net/core/dev.c	Sun Oct 31 18:53:03 1999
@@ -99,6 +99,16 @@
 NET_PROFILE_DEFINE(net_bh)
 NET_PROFILE_DEFINE(net_bh_skb)
 
+#ifdef CONFIG_SWAP_VIA_NETWORK
+#include <linux/swap.h> /* min_free_pages, swap_free_pages */
+
+#undef DEBUG_NETWORK_SWAPPING
+#ifdef DEBUG_NETWORK_SWAPPING
+#define dprintk(args...)	printk(## args)
+#else
+#define	dprintk(args...)
+#endif
+#endif
 
 const char *if_port_text[] = {
   "unknown",
@@ -193,6 +203,12 @@
 void dev_add_pack(struct packet_type *pt)
 {
 	int hash;
+
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	dprintk("Adding packet of type 0x%04x, swap: %d\n",
+	       pt->type, pt->swappable);
+#endif
+
 #ifdef CONFIG_NET_FASTROUTE
 	/* Hack to detect packet socket */
 	if (pt->data) {
@@ -522,7 +538,7 @@
 			((struct sock *)ptype->data != skb->sk))
 		{
 			struct sk_buff *skb2;
-			if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL)
+			if ((skb2 = skb_clone(skb, GFP_NUCLEONIC)) == NULL)
 				break;
 
 			/* Code, following below is wrong.
@@ -561,7 +577,7 @@
  
 void dev_loopback_xmit(struct sk_buff *skb)
 {
-	struct sk_buff *newskb=skb_clone(skb, GFP_ATOMIC);
+	struct sk_buff *newskb=skb_clone(skb, GFP_NUCLEONIC);
 	if (newskb==NULL)
 		return;
 
@@ -943,9 +959,22 @@
 		for (ptype = ptype_all; ptype!=NULL; ptype=ptype->next)
 		{
 			if (!ptype->dev || ptype->dev == skb->dev) {
-				if(pt_prev)
-				{
-					struct sk_buff *skb2=skb_clone(skb, GFP_ATOMIC);
+				
+#ifdef CONFIG_SWAP_VIA_NETWORK
+				if (pt_prev && SWAP_LOWMEM && !pt_prev->swappable) {
+					dprintk(__FUNCTION__
+						" deferring packet (0x%04x), "
+						"low memory (%d)\n",
+						pt_prev->type, nr_free_pages);
+				}
+#endif
+				if(pt_prev
+#ifdef CONFIG_SWAP_VIA_NETWORK
+				   && (!SWAP_LOWMEM || pt_prev->swappable)
+#endif
+				   ) {
+					struct sk_buff *skb2=skb_clone(skb,
+								       GFP_NUCLEONIC);
 					if(skb2)
 						pt_prev->func(skb2,skb->dev, pt_prev);
 				}
@@ -961,11 +990,23 @@
 				 *	We already have a match queued. Deliver
 				 *	to it and then remember the new match
 				 */
-				if(pt_prev)
-				{
+#ifdef CONFIG_SWAP_VIA_NETWORK
+				if (pt_prev && SWAP_LOWMEM &&
+				    !pt_prev->swappable) {
+					dprintk(__FUNCTION__
+						" deferring packet (0x%04x), "
+						"low memory (%d)\n",
+						pt_prev->type, nr_free_pages);
+				}
+#endif
+				if(pt_prev
+#ifdef CONFIG_SWAP_VIA_NETWORK
+				   && (!SWAP_LOWMEM || pt_prev->swappable)
+				   ) {
+#endif
 					struct sk_buff *skb2;
 
-					skb2=skb_clone(skb, GFP_ATOMIC);
+					skb2=skb_clone(skb, GFP_NUCLEONIC);
 
 					/*
 					 *	Kick the protocol handler. This should be fast
@@ -984,7 +1025,18 @@
 		 *	Is there a last item to send to ?
 		 */
 
-		if(pt_prev)
+#ifdef CONFIG_SWAP_VIA_NETWORK
+		if (pt_prev && SWAP_LOWMEM && !pt_prev->swappable) {
+			dprintk(__FUNCTION__ " deferring packet (0x%04x), "
+				"low memory (%d)\n",
+				pt_prev->type, nr_free_pages);
+		}
+#endif
+		if(pt_prev
+#ifdef CONFIG_SWAP_VIA_NETWORK
+		   && (!SWAP_LOWMEM || pt_prev->swappable)
+#endif
+		   )
 			pt_prev->func(skb, skb->dev, pt_prev);
 		/*
 		 * 	Has an unknown packet has been received ?
Only in linux/net/core: dev.c.orig
diff -ru linux-2.2.13pre17/net/core/dst.c linux/net/core/dst.c
--- linux-2.2.13pre17/net/core/dst.c	Tue Mar 24 00:48:25 1998
+++ linux/net/core/dst.c	Sun Oct 31 18:53:03 1999
@@ -84,7 +84,7 @@
 		if (ops->gc())
 			return NULL;
 	}
-	dst = kmalloc(size, GFP_ATOMIC);
+	dst = kmalloc(size, GFP_NUCLEONIC);
 	if (!dst)
 		return NULL;
 	memset(dst, 0, size);
diff -ru linux-2.2.13pre17/net/core/neighbour.c linux/net/core/neighbour.c
--- linux-2.2.13pre17/net/core/neighbour.c	Wed Oct 13 20:36:22 1999
+++ linux/net/core/neighbour.c	Sun Oct 31 19:14:37 1999
@@ -212,7 +212,7 @@
 		}
 	}
 
-	n = kmalloc(tbl->entry_size, GFP_ATOMIC);
+	n = kmalloc(tbl->entry_size, GFP_NUCLEONIC);
 	if (n == NULL)
 		return NULL;
 
@@ -778,7 +778,7 @@
 		if (hh->hh_type == protocol)
 			break;
 
-	if (!hh && (hh = kmalloc(sizeof(*hh), GFP_ATOMIC)) != NULL) {
+	if (!hh && (hh = kmalloc(sizeof(*hh), GFP_NUCLEONIC)) != NULL) {
 		memset(hh, 0, sizeof(struct hh_cache));
 		hh->hh_type = protocol;
 		atomic_set(&hh->hh_refcnt, 0);
@@ -1223,7 +1223,7 @@
 	struct nlmsghdr  *nlh;
 	int size = NLMSG_SPACE(sizeof(struct ndmsg)+256);
 
-	skb = alloc_skb(size, GFP_ATOMIC);
+	skb = alloc_skb(size, GFP_NUCLEONIC);
 	if (!skb)
 		return;
 
@@ -1234,7 +1234,7 @@
 	nlh = (struct nlmsghdr*)skb->data;
 	nlh->nlmsg_flags = NLM_F_REQUEST;
 	NETLINK_CB(skb).dst_groups = RTMGRP_NEIGH;
-	netlink_broadcast(rtnl, skb, 0, RTMGRP_NEIGH, GFP_ATOMIC);
+	netlink_broadcast(rtnl, skb, 0, RTMGRP_NEIGH, GFP_NUCLEONIC);
 }
 
 static void neigh_app_notify(struct neighbour *n)
@@ -1243,7 +1243,7 @@
 	struct nlmsghdr  *nlh;
 	int size = NLMSG_SPACE(sizeof(struct ndmsg)+256);
 
-	skb = alloc_skb(size, GFP_ATOMIC);
+	skb = alloc_skb(size, GFP_NUCLEONIC);
 	if (!skb)
 		return;
 
@@ -1253,7 +1253,7 @@
 	}
 	nlh = (struct nlmsghdr*)skb->data;
 	NETLINK_CB(skb).dst_groups = RTMGRP_NEIGH;
-	netlink_broadcast(rtnl, skb, 0, RTMGRP_NEIGH, GFP_ATOMIC);
+	netlink_broadcast(rtnl, skb, 0, RTMGRP_NEIGH, GFP_NUCLEONIC);
 }
 
 
Only in linux/net/core: neighbour.c.orig
Only in linux/net/core: neighbour.c.rej
Only in linux/net/core: neighbour.c~
diff -ru linux-2.2.13pre17/net/core/skbuff.c linux/net/core/skbuff.c
--- linux-2.2.13pre17/net/core/skbuff.c	Sun Mar  7 18:12:18 1999
+++ linux/net/core/skbuff.c	Sun Oct 31 18:53:03 1999
@@ -320,7 +320,7 @@
 	 *	Allocate the copy buffer
 	 */
  	 
-	n=alloc_skb(skb->truesize+newheadroom-headroom, GFP_ATOMIC);
+	n=alloc_skb(skb->truesize+newheadroom-headroom, GFP_NUCLEONIC);
 	if(n==NULL)
 		return NULL;
 
Only in linux/net/core: skbuff.c.orig
diff -ru linux-2.2.13pre17/net/core/sock.c linux/net/core/sock.c
--- linux-2.2.13pre17/net/core/sock.c	Mon May 10 16:55:25 1999
+++ linux/net/core/sock.c	Sun Oct 31 18:53:03 1999
@@ -286,7 +286,12 @@
 			sock->passcred = valbool;
 			break;
 			
-			
+		case SO_SWAPPING:
+			if(!suser())
+				return(-EPERM);
+			sk->swapping = valbool;
+			return 0;
+		
 #ifdef CONFIG_NETDEVICES
 		case SO_BINDTODEVICE:
 		{
@@ -464,6 +469,10 @@
 				return -EFAULT;
 			goto lenout;
 			
+		case SO_SWAPPING:
+			v.val = sk->swapping;
+			break;
+
 		default:
 			return(-ENOPROTOOPT);
 	}
@@ -558,6 +567,10 @@
  */
 struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force, int priority)
 {
+	if (sk->swapping) {
+		force = 1;
+		priority = GFP_NUCLEONIC;
+	}
 	if (force || atomic_read(&sk->wmem_alloc) < sk->sndbuf) {
 		struct sk_buff * skb = alloc_skb(size, priority);
 		if (skb) {
@@ -575,6 +588,10 @@
  */ 
 struct sk_buff *sock_rmalloc(struct sock *sk, unsigned long size, int force, int priority)
 {
+	if (sk->swapping) {
+		force = 1;
+		priority = GFP_NUCLEONIC;
+	}
 	if (force || atomic_read(&sk->rmem_alloc) < sk->rcvbuf) {
 		struct sk_buff *skb = alloc_skb(size, priority);
 		if (skb) {
@@ -592,6 +609,9 @@
  */ 
 void *sock_kmalloc(struct sock *sk, int size, int priority)
 {
+	if (sk->swapping) {
+		priority = GFP_NUCLEONIC;
+	}
 	if (atomic_read(&sk->omem_alloc)+size < sysctl_optmem_max) {
 		void *mem;
 		/* First do the add, to avoid the race if kmalloc
Only in linux/net/core: sock.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/arp.c linux/net/ipv4/arp.c
--- linux-2.2.13pre17/net/ipv4/arp.c	Wed Oct 13 20:51:37 1999
+++ linux/net/ipv4/arp.c	Sun Oct 31 18:53:03 1999
@@ -445,7 +445,7 @@
 	 */
 	
 	skb = alloc_skb(sizeof(struct arphdr)+ 2*(dev->addr_len+4)
-				+ dev->hard_header_len + 15, GFP_ATOMIC);
+				+ dev->hard_header_len + 15, GFP_NUCLEONIC);
 	if (skb == NULL)
 		return;
 
@@ -1095,7 +1095,10 @@
 	NULL,		/* All devices */
 	arp_rcv,
 	NULL,
-	NULL
+	NULL,
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	1,	/* DONT'T discard packets when below reserved_for_swap */
+#endif
 };
 
 #ifdef CONFIG_PROC_FS
Only in linux/net/ipv4: arp.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/icmp.c linux/net/ipv4/icmp.c
--- linux-2.2.13pre17/net/ipv4/icmp.c	Wed Oct 13 20:51:38 1999
+++ linux/net/ipv4/icmp.c	Sun Oct 31 18:53:03 1999
@@ -283,6 +283,17 @@
 #include <net/ip_masq.h>
 #endif
 
+#ifdef CONFIG_SWAP_VIA_NETWORK
+#include <linux/swap.h>
+#endif
+
+#undef DEBUG_NETWORK_SWAPPING
+#ifdef DEBUG_NETWORK_SWAPPING
+#define dprintk(args...)	printk(## args)
+#else
+#define	dprintk(args...)
+#endif
+
 #define min(a,b)	((a)<(b)?(a):(b))
 
 /*
@@ -1030,6 +1041,16 @@
 	struct icmphdr *icmph = skb->h.icmph;
 	struct rtable *rt = (struct rtable*)skb->dst;
 
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	/* is this necessary? icmp doesn't cost much ...
+	 */
+	if (SWAP_LOWMEM) {
+		dprintk(__FUNCTION__ ": Discarded packet, low memory (%d)\n",
+		       nr_free_pages);
+		kfree_skb(skb);
+		return 0;
+	}
+#endif
 	icmp_statistics.IcmpInMsgs++;
 
 	/*
@@ -1150,7 +1171,7 @@
 
 	if ((err=ops->create(icmp_socket, IPPROTO_ICMP))<0)
 		panic("Failed to create the ICMP control socket.\n");
-	icmp_socket->sk->allocation=GFP_ATOMIC;
+	icmp_socket->sk->allocation=GFP_NUCLEONIC;
 	icmp_socket->sk->num = 256;		/* Don't receive any data */
 	icmp_socket->sk->ip_ttl = MAXTTL;
 }
Only in linux/net/ipv4: icmp.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/igmp.c linux/net/ipv4/igmp.c
--- linux-2.2.13pre17/net/ipv4/igmp.c	Wed Oct 13 20:36:22 1999
+++ linux/net/ipv4/igmp.c	Sun Oct 31 18:53:03 1999
@@ -96,6 +96,16 @@
 #ifdef CONFIG_IP_MROUTE
 #include <linux/mroute.h>
 #endif
+#ifdef CONFIG_SWAP_VIA_NETWORK
+#include <linux/swap.h>
+#endif
+ 
+#undef DEBUG_NETWORK_SWAPPING
+#ifdef DEBUG_NETWORK_SWAPPING
+#define dprintk(args...)	printk(## args)
+#else
+#define	dprintk(args...)
+#endif
 
 #define IP_MAX_MEMBERSHIPS 20
 
@@ -298,6 +308,16 @@
 	/* This basically follows the spec line by line -- see RFC1112 */
 	struct igmphdr *ih = skb->h.igmph;
 	struct in_device *in_dev = skb->dev->ip_ptr;
+
+
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	if (SWAP_LOWMEM) {
+		dprintk(__FUNCTION__ ": Discarded packet, low memory (%d)\n",
+		       nr_free_pages);
+		kfree_skb(skb, FREE_READ);
+		return 0;
+	}
+#endif
 
 	if (len < sizeof(struct igmphdr) || ip_compute_csum((void *)ih, len)
 	    || in_dev==NULL) {
Only in linux/net/ipv4: igmp.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/ip_fragment.c linux/net/ipv4/ip_fragment.c
--- linux-2.2.13pre17/net/ipv4/ip_fragment.c	Sun Mar 21 15:22:00 1999
+++ linux/net/ipv4/ip_fragment.c	Sun Oct 31 18:53:03 1999
@@ -107,7 +107,8 @@
 {
 	struct ipfrag *fp;
 
-	fp = (struct ipfrag *) frag_kmalloc(sizeof(struct ipfrag), GFP_ATOMIC);
+	fp = (struct ipfrag *) frag_kmalloc(sizeof(struct ipfrag),
+					    GFP_NUCLEONIC);
 	if (fp == NULL)
 		goto out_nomem;
 
@@ -257,14 +258,14 @@
 	unsigned int hash;
 	int ihlen;
 
-	qp = (struct ipq *) frag_kmalloc(sizeof(struct ipq), GFP_ATOMIC);
+	qp = (struct ipq *) frag_kmalloc(sizeof(struct ipq), GFP_NUCLEONIC);
 	if (qp == NULL)
 		goto out_nomem;
 
 	/* Allocate memory for the IP header (plus 8 octets for ICMP). */
 	ihlen = iph->ihl * 4;
 
-	qp->iph = (struct iphdr *) frag_kmalloc(64 + 8, GFP_ATOMIC);
+	qp->iph = (struct iphdr *) frag_kmalloc(64 + 8, GFP_NUCLEONIC);
 	if (qp->iph == NULL)
 		goto out_free;
 
@@ -395,9 +396,8 @@
 	kfree_skb(skb);
 	goto out_fail;
 out_nomem:
- 	NETDEBUG(printk(KERN_ERR 
-			"IP: queue_glue: no memory for gluing queue %p\n",
-			qp));
+	NETDEBUG(printk(KERN_ERR
+			"IP: queue_glue: no memory for gluing queue %p (len %d)\n", qp, len));
 	goto out_fail;
 out_oversize:
 	if (net_ratelimit())
Only in linux/net/ipv4: ip_fragment.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/ip_input.c linux/net/ipv4/ip_input.c
--- linux-2.2.13pre17/net/ipv4/ip_input.c	Wed Oct 13 20:51:38 1999
+++ linux/net/ipv4/ip_input.c	Sun Oct 31 18:53:03 1999
@@ -205,7 +205,7 @@
 					return 1;
 			}
 			if (last) {
-				struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
+				struct sk_buff *skb2 = skb_clone(skb, GFP_NUCLEONIC);
 				if (skb2)
 					raw_rcv(last, skb2);
 			}
@@ -313,7 +313,7 @@
 				if (iph->protocol != IPPROTO_ICMP || !icmp_filter(raw_sk, skb)) {
 					if (sknext == NULL)
 						break;
-					skb1 = skb_clone(skb, GFP_ATOMIC);
+					skb1 = skb_clone(skb, GFP_NUCLEONIC);
 					if(skb1)
 					{
 						raw_rcv(raw_sk, skb1);
@@ -348,7 +348,7 @@
 	
 		if (ipprot->copy || raw_sk)
 		{
-			skb2 = skb_clone(skb, GFP_ATOMIC);
+			skb2 = skb_clone(skb, GFP_NUCLEONIC);
 			if(skb2==NULL)
 				continue;
 		}
Only in linux/net/ipv4: ip_input.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/ip_output.c linux/net/ipv4/ip_output.c
--- linux-2.2.13pre17/net/ipv4/ip_output.c	Wed Oct 13 20:51:38 1999
+++ linux/net/ipv4/ip_output.c	Sun Oct 31 18:53:03 1999
@@ -791,7 +791,7 @@
 		 *	Allocate buffer.
 		 */
 
-		if ((skb2 = alloc_skb(len+hlen+dev->hard_header_len+15,GFP_ATOMIC)) == NULL) {
+		if ((skb2 = alloc_skb(len+hlen+dev->hard_header_len+15,GFP_NUCLEONIC)) == NULL) {
 			NETDEBUG(printk(KERN_INFO "IP: frag: no memory for new fragment!\n"));
 			goto fail;
 		}
@@ -958,6 +958,9 @@
 	ip_rcv,
 	NULL,
 	NULL,
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	1,	/* DONT'T discard packets when below reserved_for_swap */
+#endif
 };
 
 
Only in linux/net/ipv4: ip_output.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/rarp.c linux/net/ipv4/rarp.c
--- linux-2.2.13pre17/net/ipv4/rarp.c	Mon Jul 27 06:35:57 1998
+++ linux/net/ipv4/rarp.c	Sun Oct 31 18:53:03 1999
@@ -69,6 +69,17 @@
 #include <linux/proc_fs.h>
 #include <linux/stat.h>
 
+#ifdef CONFIG_SWAP_VIA_NETWORK
+#include <linux/swap.h>
+#endif
+
+#undef DEBUG_NETWORK_SWAPPING
+#ifdef DEBUG_NETWORK_SWAPPING
+#define dprintk(args...)	printk(## args)
+#else
+#define	dprintk(args...)
+#endif
+
 extern int (*rarp_ioctl_hook)(unsigned int,void*);
 
 /*
@@ -96,7 +107,10 @@
 	0,                /* copy */
 	rarp_rcv,
 	NULL,
-	NULL
+	NULL,
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	0,	/* discard packets when below reserved_for_swap */
+#endif
 };
 
 static int initflag = 1;
@@ -222,6 +236,17 @@
 	long sip,tip;
 	unsigned char *sha,*tha;            /* s for "source", t for "target" */
 	
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	/* is this necessary? icmp doesn't cost much ...
+	 */
+	if (SWAP_LOWMEM) {
+		dprintk(__FUNCTION__ ": Discarded packet, low memory (%d)\n",
+		       nr_free_pages);
+		kfree_skb(skb);
+		return 0;
+	}
+#endif
+
 /*
  *	If this test doesn't pass, it's not IP, or we should ignore it anyway
  */
diff -ru linux-2.2.13pre17/net/ipv4/raw.c linux/net/ipv4/raw.c
--- linux-2.2.13pre17/net/ipv4/raw.c	Wed Oct 13 20:36:22 1999
+++ linux/net/ipv4/raw.c	Sun Oct 31 18:53:03 1999
@@ -62,6 +62,15 @@
 #include <net/raw.h>
 #include <net/checksum.h>
 
+#include <linux/swap.h>
+
+#undef DEBUG_NETWORK_SWAPPING
+#ifdef DEBUG_NETWORK_SWAPPING
+#define dprintk(args...)	printk(## args)
+#else
+#define	dprintk(args...)
+#endif
+
 #ifdef CONFIG_IP_MROUTE
 struct sock *mroute_socket=NULL;
 #endif
@@ -184,6 +193,16 @@
 
 int raw_rcv(struct sock *sk, struct sk_buff *skb)
 {
+
+	if (!sk->swapping && SWAP_LOWMEM) {
+		dprintk(__FUNCTION__ "Discarded packet, low memory (%d)\n",
+		       nr_free_pages);
+		ip_statistics.IpInDiscards++;
+		skb->sk=NULL;
+		kfree_skb(skb);
+		return 0;
+	}
+
 	/* Now we need to copy this into memory. */
 	skb_trim(skb, ntohs(skb->nh.iph->tot_len));
 	
Only in linux/net/ipv4: raw.c.orig
Only in linux/net/ipv4: raw.c.rej
diff -ru linux-2.2.13pre17/net/ipv4/tcp.c linux/net/ipv4/tcp.c
--- linux-2.2.13pre17/net/ipv4/tcp.c	Wed Oct 13 20:36:22 1999
+++ linux/net/ipv4/tcp.c	Sun Oct 31 18:53:03 1999
@@ -1795,6 +1795,12 @@
 
 extern void __skb_cb_too_small_for_tcp(int, int);
 
+#ifdef CONFIG_SWAP_VIA_NETWORK
+#define TCP_SLAB_CACHE_FLAGS (SLAB_HWCACHE_ALIGN | SLAB_LOW_GFP_ORDER)
+#else
+#define TCP_SLAB_CACHE_FLAGS SLAB_HWCACHE_ALIGN
+#endif
+
 void __init tcp_init(void)
 {
 	struct sk_buff *skb = NULL;
@@ -1805,22 +1811,23 @@
 
 	tcp_openreq_cachep = kmem_cache_create("tcp_open_request",
 						   sizeof(struct open_request),
-					       0, SLAB_HWCACHE_ALIGN,
+					       0, TCP_SLAB_CACHE_FLAGS,
 					       NULL, NULL);
 	if(!tcp_openreq_cachep)
 		panic("tcp_init: Cannot alloc open_request cache.");
 
 	tcp_bucket_cachep = kmem_cache_create("tcp_bind_bucket",
 					      sizeof(struct tcp_bind_bucket),
-					      0, SLAB_HWCACHE_ALIGN,
+					      0, TCP_SLAB_CACHE_FLAGS,
 					      NULL, NULL);
 	if(!tcp_bucket_cachep)
 		panic("tcp_init: Cannot alloc tcp_bind_bucket cache.");
 
 	tcp_timewait_cachep = kmem_cache_create("tcp_tw_bucket",
 						sizeof(struct tcp_tw_bucket),
-						0, SLAB_HWCACHE_ALIGN,
+						0, TCP_SLAB_CACHE_FLAGS,
 						NULL, NULL);
+
 	if(!tcp_timewait_cachep)
 		panic("tcp_init: Cannot alloc tcp_tw_bucket cache.");
 }
Only in linux/net/ipv4: tcp.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/tcp_input.c linux/net/ipv4/tcp_input.c
--- linux-2.2.13pre17/net/ipv4/tcp_input.c	Wed Oct 13 20:36:45 1999
+++ linux/net/ipv4/tcp_input.c	Sun Oct 31 18:53:03 1999
@@ -1055,7 +1055,8 @@
 {
 	struct tcp_tw_bucket *tw;
 
-	tw = kmem_cache_alloc(tcp_timewait_cachep, SLAB_ATOMIC);
+	tw = kmem_cache_alloc(tcp_timewait_cachep,
+			      sk->swapping ? SLAB_NUCLEONIC : SLAB_ATOMIC);
 	if(tw != NULL) {
 		/* Give us an identity. */
 		tw->daddr	= sk->daddr;
Only in linux/net/ipv4: tcp_input.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/tcp_ipv4.c linux/net/ipv4/tcp_ipv4.c
--- linux-2.2.13pre17/net/ipv4/tcp_ipv4.c	Wed Oct 13 20:51:38 1999
+++ linux/net/ipv4/tcp_ipv4.c	Sun Oct 31 18:53:04 1999
@@ -63,6 +63,17 @@
 #include <linux/inet.h>
 #include <linux/stddef.h>
 
+#ifdef CONFIG_SWAP_VIA_NETWORK
+#include <linux/swap.h>
+
+#undef DEBUG_NETWORK_SWAPPING
+#ifdef DEBUG_NETWORK_SWAPPING
+#define dprintk(args...)	printk(## args)
+#else
+#define	dprintk(args...)
+#endif
+#endif
+
 extern int sysctl_tcp_timestamps;
 extern int sysctl_tcp_window_scaling;
 extern int sysctl_tcp_sack;
@@ -137,7 +148,7 @@
 {
 	struct tcp_bind_bucket *tb;
 
-	tb = kmem_cache_alloc(tcp_bucket_cachep, SLAB_ATOMIC);
+	tb = kmem_cache_alloc(tcp_bucket_cachep, SLAB_NUCLEONIC);
 	if(tb != NULL) {
 		struct tcp_bind_bucket **head =
 			&tcp_bound_hash[tcp_bhashfn(snum)];
@@ -1205,8 +1216,9 @@
 	struct ip_options *dopt = NULL; 
 
 	if (opt && opt->optlen) {
-		int opt_size = optlength(opt); 
-		dopt = kmalloc(opt_size, GFP_ATOMIC);
+		int opt_size = optlength(opt);
+		dopt = kmalloc(opt_size,
+			       sk->swapping ? GFP_NUCLEONIC : GFP_ATOMIC);
 		if (dopt) {
 			if (ip_options_echo(dopt, skb)) {
 				kfree_s(dopt, opt_size);
@@ -1353,7 +1365,9 @@
  */
 struct sock *tcp_create_openreq_child(struct sock *sk, struct open_request *req, struct sk_buff *skb)
 {
-	struct sock *newsk = sk_alloc(PF_INET, GFP_ATOMIC, 0);
+	struct sock *newsk = sk_alloc(PF_INET, 
+				      sk->swapping ? GFP_NUCLEONIC:GFP_ATOMIC,
+				      0);
 
 	if(newsk != NULL) {
 		struct tcp_opt *newtp;
@@ -1748,6 +1762,14 @@
 #endif
 	if (!sk)
 		goto no_tcp_socket;
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	if (SWAP_LOWMEM && !sk->swapping) {
+		dprintk(__FUNCTION__ 
+			": Discarded packet, low memory (%d)\n",
+			nr_free_pages);
+		goto discard_it;
+	}
+#endif
 	if(!ipsec_sk_policy(sk,skb))
 		goto discard_it;
 
Only in linux/net/ipv4: tcp_ipv4.c.orig
diff -ru linux-2.2.13pre17/net/ipv4/tcp_output.c linux/net/ipv4/tcp_output.c
--- linux-2.2.13pre17/net/ipv4/tcp_output.c	Wed Jun  2 16:55:22 1999
+++ linux/net/ipv4/tcp_output.c	Sun Oct 31 19:17:14 1999
@@ -352,7 +352,10 @@
 			TCP_SKB_CB(skb)->when = tcp_time_stamp;
 			tp->snd_nxt = TCP_SKB_CB(skb)->end_seq;
 			tp->packets_out++;
-			tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC));
+			tcp_transmit_skb(sk, skb_clone(skb,
+						       sk->swapping
+						       ? GFP_NUCLEONIC
+						       : GFP_ATOMIC));
 			sent_pkts = 1;
 		}
 
@@ -622,9 +625,9 @@
 	 */
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
 	if(skb_cloned(skb))
-		skb = skb_copy(skb, GFP_ATOMIC);
+		skb = skb_copy(skb, sk->swapping ? GFP_NUCLEONIC : GFP_ATOMIC);
 	else
-		skb = skb_clone(skb, GFP_ATOMIC);
+		skb = skb_clone(skb, sk->swapping ? GFP_NUCLEONIC : GFP_ATOMIC);
 
 	tcp_transmit_skb(sk, skb);
 
@@ -746,7 +749,10 @@
 			TCP_SKB_CB(skb)->when = tcp_time_stamp;
 			tp->snd_nxt = TCP_SKB_CB(skb)->end_seq;
 			tp->packets_out++;
-			tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC));
+			tcp_transmit_skb(sk, skb_clone(skb,
+						       sk->swapping
+						       ? GFP_NUCLEONIC
+						       : GFP_ATOMIC));
 			if(!tcp_timer_is_set(sk, TIME_RETRANS))
 				tcp_reset_xmit_timer(sk, TIME_RETRANS, tp->rto);
 		}
@@ -830,7 +836,9 @@
 	__skb_queue_tail(&sk->write_queue, skb);
 	TCP_SKB_CB(skb)->when = tcp_time_stamp;
 	tp->packets_out++;
-	tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC));
+	tcp_transmit_skb(sk,
+			 skb_clone(skb,
+				   sk->swapping ? GFP_NUCLEONIC : GFP_KERNEL));
 	return 0;
 }
 
@@ -1031,7 +1039,8 @@
 		 * tcp_transmit_skb() will set the ownership to this
 		 * sock.
 		 */
-		buff = alloc_skb(MAX_HEADER + sk->prot->max_header, GFP_ATOMIC);
+		buff = alloc_skb(MAX_HEADER + sk->prot->max_header,
+				 sk->swapping ? GFP_NUCLEONIC : GFP_ATOMIC);
 		if (buff == NULL) {
 			/* Force it to send an ack. We don't have to do this
 			 * (ACK is unreliable) but it's much better use of
@@ -1098,13 +1107,17 @@
 			TCP_SKB_CB(skb)->when = tcp_time_stamp;
 			tp->snd_nxt = TCP_SKB_CB(skb)->end_seq;
 			tp->packets_out++;
-			tcp_transmit_skb(sk, skb_clone(skb, GFP_ATOMIC));
+			tcp_transmit_skb(sk, skb_clone(skb,
+						       sk->swapping
+						       ? GFP_NUCLEONIC
+						       : GFP_ATOMIC));
 			if (!tcp_timer_is_set(sk, TIME_RETRANS))
 				tcp_reset_xmit_timer(sk, TIME_RETRANS, tp->rto);
 		} else {
 			/* We don't queue it, tcp_transmit_skb() sets ownership. */
 			skb = alloc_skb(MAX_HEADER + sk->prot->max_header,
-					GFP_ATOMIC);
+					sk->swapping
+					? GFP_NUCLEONIC : GFP_ATOMIC);
 			if (skb == NULL) 
 				return;
 
Only in linux/net/ipv4: tcp_output.c.orig
Only in linux/net/ipv4: tcp_output.c.rej
Only in linux/net/ipv4: tcp_output.c~
diff -ru linux-2.2.13pre17/net/ipv4/udp.c linux/net/ipv4/udp.c
--- linux-2.2.13pre17/net/ipv4/udp.c	Wed Oct 13 20:36:22 1999
+++ linux/net/ipv4/udp.c	Sun Oct 31 18:53:04 1999
@@ -115,6 +115,17 @@
 #include <net/route.h>
 #include <net/checksum.h>
 
+#ifdef CONFIG_SWAP_VIA_NETWORK
+#include <linux/swap.h>
+
+#undef DEBUG_NETWORK_SWAPPING
+#ifdef DEBUG_NETWORK_SWAPPING
+#define dprintk(args...)	printk(## args)
+#else
+#define	dprintk(args...)
+#endif
+#endif
+
 /*
  *	Snmp MIB for the UDP layer
  */
@@ -984,6 +995,8 @@
 		ip_statistics.IpInDiscards++;
 		ip_statistics.IpInDelivers--;
 		kfree_skb(skb);
+		dprintk(__FUNCTION__ ": Discarded packet, low memory (%d, @ %p)\n",
+			nr_free_pages, sk);
 		return -1;
 	}
 	udp_statistics.UdpInDatagrams++;
@@ -993,6 +1006,19 @@
 
 static inline void udp_deliver(struct sock *sk, struct sk_buff *skb)
 {
+
+#ifdef CONFIG_SWAP_VIA_NETWORK
+	if (!sk->swapping && SWAP_LOWMEM) {
+		udp_statistics.UdpInErrors++;
+		ip_statistics.IpInDiscards++;
+		ip_statistics.IpInDelivers--;
+		skb->sk = NULL;
+		kfree_skb(skb);
+		dprintk(__FUNCTION__ ": Discarded packet, low memory (%d, @ %p)\n",
+		       nr_free_pages, sk);
+		return;
+	}
+#endif
 	udp_queue_rcv_skb(sk, skb);
 }
 
@@ -1020,7 +1046,10 @@
 			sknext = udp_v4_mcast_next(sk->next, uh->dest, saddr,
 						   uh->source, daddr, dif);
 			if(sknext)
-				skb1 = skb_clone(skb, GFP_ATOMIC);
+				skb1 = skb_clone(skb,
+						 sk->swapping
+						 ? GFP_NUCLEONIC
+						 : GFP_ATOMIC);
 
 			if(skb1)
 				udp_deliver(sk, skb1);
Only in linux/net/ipv4: udp.c.orig
Only in linux/net/ipv4: udp.c.rej


Here is the reject that I didn't know what to do with.

: ::: ./linux/mm/slab.c.rej
: 
: ***************
: *** 1257,1263 ****
:   	kmem_freepages(cachep, objp); 
:   failed:
:   	spin_lock_irq(&cachep->c_spinlock);
: - 	if (local_flags != SLAB_ATOMIC && cachep->c_gfporder) {
:   		/* For large order (>0) slabs, we try again.
:   		 * Needed because the gfp() functions are not good at giving
:   		 * out contiguous pages unless pushed (but do not push too hard).
: --- 1260,1266 ----
:   	kmem_freepages(cachep, objp); 
:   failed:
:   	spin_lock_irq(&cachep->c_spinlock);
: + 	if ((local_flags & SLAB_WAIT) && cachep->c_gfporder) {
:   		/* For large order (>0) slabs, we try again.
:   		 * Needed because the gfp() functions are not good at giving
:   		 * out contiguous pages unless pushed (but do not push too hard).
: 
